<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>貪吃蛇</title>
  <style>
    :root {
      --bg1: #0f1324;
      --bg2: #1b244a;
      --panel: rgba(255, 255, 255, 0.08);
      --accent: #ffb703;
      --snake: #8ef7a0;
      --food: #ff5d73;
      --grid: rgba(255, 255, 255, 0.08);
      --text: #e8ecff;
    }

    * { box-sizing: border-box; }

    html, body {
      height: 100%;
      margin: 0;
      font-family: "Alegreya Sans", "Avenir Next", system-ui, sans-serif;
      color: var(--text);
      background: radial-gradient(1200px 800px at 10% 10%, #202b57, transparent),
                  radial-gradient(900px 700px at 90% 20%, #2c1c4d, transparent),
                  linear-gradient(160deg, var(--bg1), var(--bg2));
    }

    main {
      min-height: 100%;
      display: grid;
      grid-template-columns: minmax(280px, 420px) 1fr;
      gap: 24px;
      padding: 28px;
      align-items: center;
    }

    .panel {
      background: var(--panel);
      border: 1px solid rgba(255, 255, 255, 0.12);
      backdrop-filter: blur(12px);
      border-radius: 20px;
      padding: 22px;
      box-shadow: 0 20px 50px rgba(9, 12, 34, 0.45);
    }

    h1 {
      font-size: clamp(28px, 4vw, 40px);
      margin: 0 0 12px;
      letter-spacing: 1px;
    }

    .meta {
      display: grid;
      gap: 12px;
      margin: 18px 0;
    }

    .score {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 18px;
    }

    .score strong {
      font-size: 28px;
      color: var(--accent);
      letter-spacing: 1px;
    }

    .controls {
      display: grid;
      gap: 10px;
      font-size: 14px;
      line-height: 1.5;
      opacity: 0.9;
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 10px 18px;
      font-size: 15px;
      cursor: pointer;
      background: var(--accent);
      color: #1c1300;
      font-weight: 700;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255, 183, 3, 0.3); }
    button:active { transform: translateY(0); }

    canvas {
      width: min(88vw, 720px);
      aspect-ratio: 1;
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(9, 12, 34, 0.65);
      box-shadow: 0 24px 60px rgba(9, 12, 34, 0.5);
    }

    .tag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.12);
      width: fit-content;
    }

    @media (max-width: 860px) {
      main { grid-template-columns: 1fr; }
      canvas { width: 92vw; }
    }
  </style>
</head>
<body>
  <main>
    <section class="panel">
      <div class="tag">Snake · Arcade</div>
      <h1>貪吃蛇小遊戲</h1>
      <p>吃到越多點心，速度越快。撞到牆或自己就會結束。</p>

      <div class="meta">
        <div class="score">
          <span>目前分數</span>
          <strong id="score">0</strong>
        </div>
        <div class="score">
          <span>最高分</span>
          <strong id="best">0</strong>
        </div>
      </div>

      <button id="startBtn">開始 / 重新開始</button>

      <div class="controls">
        <div>方向鍵或 WASD 移動</div>
        <div>空白鍵暫停 / 繼續</div>
      </div>
    </section>

    <canvas id="board" width="520" height="520"></canvas>
  </main>

  <script>
    const canvas = document.getElementById('board');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const bestEl = document.getElementById('best');
    const startBtn = document.getElementById('startBtn');

    const size = 20;
    const gridCount = canvas.width / size;

    let snake;
    let direction;
    let nextDirection;
    let food;
    let score;
    let best;
    let speed;
    let loopId = null;
    let paused = false;

    const bestKey = 'snake-best-score-v1';

    const dirs = {
      ArrowUp: { x: 0, y: -1 },
      ArrowDown: { x: 0, y: 1 },
      ArrowLeft: { x: -1, y: 0 },
      ArrowRight: { x: 1, y: 0 },
      w: { x: 0, y: -1 },
      s: { x: 0, y: 1 },
      a: { x: -1, y: 0 },
      d: { x: 1, y: 0 },
    };

    function init() {
      snake = [
        { x: 10, y: 12 },
        { x: 9, y: 12 },
        { x: 8, y: 12 },
      ];
      direction = { x: 1, y: 0 };
      nextDirection = { ...direction };
      food = spawnFood();
      score = 0;
      speed = 140;
      paused = false;
      scoreEl.textContent = score;
      if (!best) {
        best = Number(localStorage.getItem(bestKey) || 0);
        bestEl.textContent = best;
      }
      draw();
      tick();
    }

    function spawnFood() {
      while (true) {
        const pos = {
          x: Math.floor(Math.random() * gridCount),
          y: Math.floor(Math.random() * gridCount),
        };
        if (!snake || !snake.some(seg => seg.x === pos.x && seg.y === pos.y)) {
          return pos;
        }
      }
    }

    function tick() {
      clearTimeout(loopId);
      loopId = setTimeout(() => {
        if (!paused) update();
        draw();
        tick();
      }, speed);
    }

    function update() {
      direction = nextDirection;
      const head = { x: snake[0].x + direction.x, y: snake[0].y + direction.y };

      if (head.x < 0 || head.y < 0 || head.x >= gridCount || head.y >= gridCount) {
        return gameOver();
      }

      if (snake.some(seg => seg.x === head.x && seg.y === head.y)) {
        return gameOver();
      }

      snake.unshift(head);

      if (head.x === food.x && head.y === food.y) {
        score += 10;
        scoreEl.textContent = score;
        if (score > best) {
          best = score;
          bestEl.textContent = best;
          localStorage.setItem(bestKey, String(best));
        }
        speed = Math.max(70, speed - 4);
        food = spawnFood();
      } else {
        snake.pop();
      }
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid');
      ctx.lineWidth = 1;
      for (let i = 0; i <= gridCount; i++) {
        const pos = i * size;
        ctx.beginPath();
        ctx.moveTo(pos, 0);
        ctx.lineTo(pos, canvas.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, pos);
        ctx.lineTo(canvas.width, pos);
        ctx.stroke();
      }
      ctx.restore();

      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--food');
      drawRoundedCell(food.x, food.y, 6);

      snake.forEach((seg, index) => {
        ctx.fillStyle = index === 0 ? '#b8ffcb' : getComputedStyle(document.documentElement).getPropertyValue('--snake');
        drawRoundedCell(seg.x, seg.y, index === 0 ? 8 : 6);
      });

      if (paused) {
        ctx.fillStyle = 'rgba(0,0,0,0.45)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#fff';
        ctx.font = 'bold 32px "Alegreya Sans", sans-serif';
        ctx.textAlign = 'center';
        ctx.fillText('暫停', canvas.width / 2, canvas.height / 2);
      }
    }

    function drawRoundedCell(x, y, radius) {
      const px = x * size + 2;
      const py = y * size + 2;
      const cell = size - 4;

      ctx.beginPath();
      ctx.moveTo(px + radius, py);
      ctx.arcTo(px + cell, py, px + cell, py + cell, radius);
      ctx.arcTo(px + cell, py + cell, px, py + cell, radius);
      ctx.arcTo(px, py + cell, px, py, radius);
      ctx.arcTo(px, py, px + cell, py, radius);
      ctx.closePath();
      ctx.fill();
    }

    function gameOver() {
      clearTimeout(loopId);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.55)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 34px "Alegreya Sans", sans-serif';
      ctx.textAlign = 'center';
      ctx.fillText('遊戲結束', canvas.width / 2, canvas.height / 2 - 8);
      ctx.font = '20px "Alegreya Sans", sans-serif';
      ctx.fillText('按開始重新玩', canvas.width / 2, canvas.height / 2 + 28);
    }

    function canChangeTo(dir) {
      return !(dir.x + direction.x === 0 && dir.y + direction.y === 0);
    }

    document.addEventListener('keydown', (event) => {
      if (event.code === 'Space') {
        paused = !paused;
        return;
      }
      const dir = dirs[event.key] || dirs[event.key?.toLowerCase?.()];
      if (!dir) return;
      if (canChangeTo(dir)) {
        nextDirection = dir;
      }
    });

    startBtn.addEventListener('click', () => {
      init();
    });

    best = Number(localStorage.getItem(bestKey) || 0);
    bestEl.textContent = best;
    draw();
  </script>
</body>
</html>
